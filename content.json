[{"title":"blog4","date":"2018-03-23T03:59:02.000Z","path":"2018/03/23/blog4/","text":"cors共享它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。（1) 请求方法是以下三种方法之一： HEAD GET POST（2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 12345var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 nginx转发处理由于跨域共享在一些浏览器不支持，所以跨域共享并非最佳方案。 nginx反向代理,但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求。搭建一个nginx并把相应代码部署在它的下面，由页面请求本域名的一个地址，转由nginx代理处理后返回结果给页面，而且这一切都是同步的。 关于nginx的一些基本配置和安装请看我后续推出的另一篇博客，下面直接讲解如何配置一个反向代理。 先找到nginx.conf或者nginx.conf.default123456789server&#123; location /｛ #所有以/开头的地址，实际上是所有请求 root html ＃去请求../html文件夹里的文件,其中..的路径在nginx里面有定义，安装的时候会有默认路径，详见另一篇博客 index index.html index.htm ＃首页响应地址 ｝&#125; 从上面可以看出location是nginx用来路由的入口，所以我们接下来要在location里面完成我们的反向代理。123456789101112131415161718server &#123; listen 8094; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location /apis &#123; rewrite ^.+apis/?(.*)$ /$1 break; include uwsgi_params; proxy_pass http://localhost:1894; &#125;&#125; 配置说明：配置一个/apis 重写到我们真正的api地址http://localhost:1894 形成一个代理的过程。 这样就没有跨域问题了 node转发处理全局配置12345678app.all(&apos;*&apos;, function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;) if(req.method==&quot;OPTIONS&quot;) res.send(200);/*让options请求快速返回*/ else next();&#125;); 1是Access-Control-Allow-Origin 允许的域2是Access-Control-Allow-Headers 允许的header类型 第一项可以直接设为* 表示任意但是第二项不能这样写，在chrome中测试跨域发现报错. 中间件处理方法一 request包1234app.use('/', function(req, res) &#123; let url = serverUrl + req.url; req.pipe(request(url)).pipe(res);&#125;); 方法二 http-proxy-middleware包12345var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy(&#123; target: 'http://www.baidu.com', changeOrigin: true &#125;));app.listen(3000);","tags":[{"name":"常见的跨域解决方案","slug":"常见的跨域解决方案","permalink":"http://yoursite.com/tags/常见的跨域解决方案/"}]},{"title":"vue的使用场景","date":"2018-03-23T03:16:14.000Z","path":"2018/03/23/blog1/","text":"Nuxt.js简单的说是Vue.js的通用框架，最常用的就是用来作SSR（服务器端渲染）。再直白点说，就是Vue.js原来是开发SPA（单页应用）的，但是随着技术的普及，很多人想用Vue开发多页应用，并在服务端完成渲染。这时候就出现了Nuxt.js这个框架，她简化了SSR的开发难度。还可以直接用命令把我们制作的vue项目生成为静态html。 服务端渲染的好处最主要的原因时SPA（单页应用）不利于搜索引擎的SEO操作。比如你作一个新闻网站，流量的一个主要来源是通过百度、谷歌、bing这些搜索引擎，但是它们对SPA的抓取并不好，特别是百度根本没法抓取到SPA的内容页面，所以我们必须把我们的应用在服务端渲染成适合搜索引擎抓取的页面，再下载到客户端。那Nuxt.js适合作新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。如果你要作移动端的项目，就没必要使用这个框架了。（其实Nuxt.js个人觉的是一个解决方案） Nuxt.js特点（优点):1、基于 Vue.js2、自动代码分层3、服务端渲染4、强大的路由功能，支持异步数据5、静态文件服务6、ES6/ES7 语法支持7、打包和压缩 JS 和 CSS8、HTML头部标签管理9、本地开发支持热加载10、集成ESLint11、支持各种样式预处理器： SASS、LESS、 Stylus等等 我觉得nuxt最大的方便之处就是它可以按照创建文件的路径自动把路由分配好,而且他也把vuex集成进去了 不需要你额外配置，简直是非常省事。 传统spa应用传统spa应用我觉得适合一些后台管理和对seo没那么大需求的情况下用比较好，如果还是希望用传统spa应用来做流量网站的话我建议拆分成多页的，通过配置多个入口,一个类别一个页面。然后还有一种方式，一个大神出了一个预渲染插件，可以生成静态html。 移动应用hybird混合开发混合开发我觉得就没有必要用服务端渲染了，还是用传统的spa应用或者是更传统的一个页面一个页面的去引。 用store去管理数据我觉得在hybird开发里比较好。","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"webpack成神之路","date":"2018-03-19T09:48:32.000Z","path":"2018/03/19/blog3/","text":"现在的前端网页功能丰富，特别是SPA（single page web application 单页应用）技术流行后，JavaScript的复杂度增加和需要一大堆依赖包，还需要解决SCSS，Less……新增样式的扩展写法的编译工作。所以现代化的前端已经完全依赖于WebPack的辅助了。 什么是WebPack？WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在3.0出现后，Webpack还肩负起了优化项目的责任。 配置文件入口和出口在我所经历的项目里有多页打包也有单页入口打包，无外乎就是入口不一样123456789101112module.exports=&#123; //入口文件的配置项 entry:&#123;&#125;, //出口文件的配置项 output:&#123;&#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; 入口配置12345//入口文件的配置项entry:&#123; //里面的entery是可以随便写的 entry:&apos;./src/entry.js&apos;&#125; output选项（出口配置）12345678910//出口文件的配置项output:&#123; //打包的路径文职 path:path.resolve(__dirname,&apos;dist&apos;), //打包的文件名称 filename:&apos;bundle.js&apos; &#125;其实path.resolve(__dirname,&apos;dist&apos;)就是获取了项目的绝对路径filename:是打包后的文件名称，这里我们起名为bundle.js 多入口、多出口配置Webpack在版本1的时候很难设置多出口文件，但是在2版本开始就变的很方便了。直接看多入口和多出口的文件配置，然后可以和单一出口对比一下，你会发现这种设置非常简单（只需改动两点配置就可以）。12345678910111213141516171819202122const path = require(&apos;path&apos;);module.exports=&#123; //入口文件的配置项 entry:&#123; entry:&apos;./src/entry.js&apos;, //这里我们又引入了一个入口文件 entry2:&apos;./src/entry2.js&apos; &#125;, //出口文件的配置项 output:&#123; //输出的路径，用了Node语法 path:path.resolve(__dirname,&apos;dist&apos;), //输出的文件名称 filename:&apos;[name].js&apos; &#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; 模块：CSS文件打包Loaders简单的举几个Loaders使用例子： 可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。可以把React中的JSX转换成JavaScript代码。 注意：所有的Loaders都需要在npm中单独进行安装，下面我们对Loaders的配置型简单梳理一下。test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错；include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；query：为loaders提供额外的设置选项（可选）。 举个例子 12345678module:&#123; rules: [ &#123; test: /\\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ] &#125; 插件机制我觉得webpack打包工具的最大贡献就是可以处理缓存策略 有些时候我们不希望将一些第三方库都打包到业务模块里 需要单独抽离出来打包，而且还希望缓存这些包 独立打包123456789101112131415module.exports = &#123; entry: &#123; main: &apos;./app/index.js&apos;, vendor: [&apos;jquery&apos;] &#125;, output: &#123; filename: &apos;[name].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos; &#125;), ]&#125; 上方我们将原本的单入口文件改成了多入口文件，并加入了vendor属性。vendor属性用于配置打包第三方类库，写入数组的类库名将统一打包到一个文件里。 同时我们将输出的filename用[name]变量来自动生成文件名，最后我们添加了一个CommonsChunkPlugin的插件，用于提取vendor。 12345678910Hash: ee1daf95c1986768927aVersion: webpack 2.3.2Time: 573ms Asset Size Chunks Chunk Names main.js 340 bytes 0 [emitted] mainvendor.js 274 kB 1 [emitted] [big] vendor [0] ./~/jquery/dist/jquery.js 267 kB &#123;1&#125; [built] [1] ./app/hello.js 53 bytes &#123;0&#125; [built] [2] ./app/index.js 114 bytes &#123;0&#125; [built] [3] multi jquery 28 bytes &#123;1&#125; [built] 最终发现我们成功将jQuery打包到了vendor.js中，实现了独立打包，但是问题又来了：每次打包后生成的文件名都是一样的，浏览器可能缓存上一次的结果而无法加载最新数据。 添加hash为了解决上述问题，我们需要为打包后的文件名添加hash值，这样每次修改后打包的文件hash值将改变，修改配置文件如下：12345678module.exports = &#123; ... output: &#123; filename: &apos;[name].[chunkHash:5].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, ...&#125; 上方我们在输出文件名中增加了[chunkHash:5]变量，表示打包后的文件中加入保留5位的hash值。我们再次运行打包命令：12345678910Hash: c7d1295f2f9a27c412d2Version: webpack 2.3.2Time: 603ms Asset Size Chunks Chunk Names main.2a7ad.js 337 bytes 0 [emitted] mainvendor.49eb4.js 274 kB 1 [emitted] [big] vendor [0] ./~/jquery/dist/jquery.js 267 kB &#123;1&#125; [built] [1] ./app/hello.js 50 bytes &#123;0&#125; [built] [2] ./app/index.js 114 bytes &#123;0&#125; [built] [3] multi jquery 28 bytes &#123;1&#125; [built] 上方我们发现打包后的文件成功加上了hash值，这样每次修改文件后hash值也会跟着变，就不怕浏览器缓存了，但是当我们尝试去修改一个js文件后再次打包，问题又来了：vendor.js的hash值也变了，我们并没有修改jQuery的源码。 修改vendor配置上述问题产生的原因是因为CommonsChunkPlugin插件是用于提取公共代码的，上方我们只是提取了vendor作为公共代码。为了继续解决上述问题，其实方法很简单，我们需要修改CommonsChunkPlugin的配置，如下：123456789module.exports = &#123; ... plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123; names: [&apos;vendor&apos;, &apos;manifest&apos;] &#125;), ] ...&#125; 如此我们修改一下hello.js中的代码，发现vendor的hash值并未改变，并且多了一个manifest.js的小文件。manifest.js为webpack的启动文件代码，它会直接影响到hash值，用mainfest单独抽出来了，这样vendor的hash就不会变了。 生成index.html通过以上对webpack配置文件的一系列修改，我们成功实现了webpack的独立打包与缓存处理，但是还差最后一步。 因为我们最终打包后生成的文件名中带有hash值，每次都是会变的，所以我们不能像目前这样在index.html中写死路径。 1234567...&lt;body&gt; &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./dist/vendor.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./dist/manifest.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;... 以上写法是不对的，因为缺少了可变的hash值，因此我们希望每次打包后index.html中的路径也会自动加上hash值，解决方法如下：1234567891011121314var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; ... plugins:[ ... new HtmlWebpackPlugin(&#123; title: &apos;demo&apos;, template: &apos;index.html&apos; // 模板路径 &#125;), ... ] ...&#125; 安装和配置完毕后，运行打包命令123456789101112Hash: 0c4b91e206579b31544dVersion: webpack 2.3.2Time: 856ms Asset Size Chunks Chunk Names vendor.e1868.js 268 kB 0 [emitted] [big] vendor main.44412.js 337 bytes 1 [emitted] mainmanifest.ed186.js 5.81 kB 2 [emitted] manifest index.html 292 bytes [emitted] [0] ./~/jquery/dist/jquery.js 267 kB &#123;0&#125; [built] [1] ./app/hello.js 50 bytes &#123;1&#125; [built] [2] ./app/index.js 114 bytes &#123;1&#125; [built] [3] multi jquery 28 bytes &#123;0&#125; [built] 我们发现在dist目录下生成了一个index.html文件，打开该文件后代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;manifest.ed186.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;vendor.e1868.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;main.44412.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"es6规范","date":"2018-03-19T09:25:22.000Z","path":"2018/03/19/blog2/","text":"es6 es7 es8 typescript 这些都是为了让一些语法逻辑更为简洁 常量12const a = xxxconst obj =&#123;&#125; 变量1let a = xxx 模版字符串传统的JavaScript语言，输出模板通常是这样写的。 12const welcome = 'You have logged in as ' + first + ' ' + last + '.'const db = 'http://' + host + ':' + port + '/' + database; ES6可以使用反引号和${}简写： 123const welcome = `You have logged in as $&#123;first&#125; $&#123;last&#125;`;const db = `http://$&#123;host&#125;:$&#123;port&#125;/$&#123;database&#125;`; 解构赋值简写方法123456789const observable = require('mobx/observable');const action = require('mobx/action');const runInAction = require('mobx/runInAction');const store = this.props.store;const form = this.props.form;const loading = this.props.loading;const errors = this.props.errors;const entity = this.props.entity; 简写:123import &#123; observable, action, runInAction &#125; from 'mobx';const &#123; store, form, loading, errors, entity &#125; = this.props; 扩展运算符简写扩展运算符有几种用例让JavaScript代码更加有效使用，可以用来代替某个数组函数。1234567// joining arraysconst odd = [1, 3, 5];const nums = [2 ,4 , 6].concat(odd);// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = arr.slice() 简写： 1234567const odd = [1, 3, 5 ];const nums = [2 ,4 , 6, ...odd];console.log(nums); // [ 2, 4, 6, 1, 3, 5 ]// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = [...arr]; 也可以使用扩展运算符解构： 1234const &#123; a, b, ...z &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(a) // 1console.log(b) // 2console.log(z) // &#123; c: 3, d: 4 &#125; 对象的扩展Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 数组方法Map filter forEach (es5常用) find方法 扩展符 想从数组中查找某个值，则需要循环。在ES6中，find()函数能实现同样效果。 12345678910111213const pets = [ &#123; type: 'Dog', name: 'Max'&#125;, &#123; type: 'Cat', name: 'Karl'&#125;, &#123; type: 'Dog', name: 'Tommy'&#125;,]function findDog(name) &#123; for(let i = 0; i&lt;pets.length; ++i) &#123; if(pets[i].type === 'Dog' &amp;&amp; pets[i].name === name) &#123; return pets[i]; &#125; &#125;&#125; 简写：12pet = pets.find(pet =&gt; pet.type ==='Dog' &amp;&amp; pet.name === 'Tommy');console.log(pet); // &#123; type: 'Dog', name: 'Tommy' &#125; 异步操作promise用法 链接 http://es6.ruanyifeng.com/#docs/promise async await 链接 http://es6.ruanyifeng.com/#docs/async","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]