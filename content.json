[{"title":"webpack成神之路","date":"2018-03-19T09:48:32.000Z","path":"2018/03/19/blog3/","text":"现在的前端网页功能丰富，特别是SPA（single page web application 单页应用）技术流行后，JavaScript的复杂度增加和需要一大堆依赖包，还需要解决SCSS，Less……新增样式的扩展写法的编译工作。所以现代化的前端已经完全依赖于WebPack的辅助了。 什么是WebPack？WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在3.0出现后，Webpack还肩负起了优化项目的责任。 配置文件入口和出口在我所经历的项目里有多页打包也有单页入口打包，无外乎就是入口不一样123456789101112module.exports=&#123; //入口文件的配置项 entry:&#123;&#125;, //出口文件的配置项 output:&#123;&#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; 入口配置12345//入口文件的配置项entry:&#123; //里面的entery是可以随便写的 entry:&apos;./src/entry.js&apos;&#125; output选项（出口配置）12345678910//出口文件的配置项output:&#123; //打包的路径文职 path:path.resolve(__dirname,&apos;dist&apos;), //打包的文件名称 filename:&apos;bundle.js&apos; &#125;其实path.resolve(__dirname,&apos;dist&apos;)就是获取了项目的绝对路径filename:是打包后的文件名称，这里我们起名为bundle.js 多入口、多出口配置Webpack在版本1的时候很难设置多出口文件，但是在2版本开始就变的很方便了。直接看多入口和多出口的文件配置，然后可以和单一出口对比一下，你会发现这种设置非常简单（只需改动两点配置就可以）。12345678910111213141516171819202122const path = require(&apos;path&apos;);module.exports=&#123; //入口文件的配置项 entry:&#123; entry:&apos;./src/entry.js&apos;, //这里我们又引入了一个入口文件 entry2:&apos;./src/entry2.js&apos; &#125;, //出口文件的配置项 output:&#123; //输出的路径，用了Node语法 path:path.resolve(__dirname,&apos;dist&apos;), //输出的文件名称 filename:&apos;[name].js&apos; &#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; 模块：CSS文件打包Loaders简单的举几个Loaders使用例子： 可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。可以把React中的JSX转换成JavaScript代码。 注意：所有的Loaders都需要在npm中单独进行安装，下面我们对Loaders的配置型简单梳理一下。test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错；include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；query：为loaders提供额外的设置选项（可选）。 举个例子 12345678module:&#123; rules: [ &#123; test: /\\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ] &#125; 插件机制我觉得webpack打包工具的最大贡献就是可以处理缓存策略 有些时候我们不希望将一些第三方库都打包到业务模块里 需要单独抽离出来打包，而且还希望缓存这些包 独立打包123456789101112131415module.exports = &#123; entry: &#123; main: &apos;./app/index.js&apos;, vendor: [&apos;jquery&apos;] &#125;, output: &#123; filename: &apos;[name].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos; &#125;), ]&#125; 上方我们将原本的单入口文件改成了多入口文件，并加入了vendor属性。vendor属性用于配置打包第三方类库，写入数组的类库名将统一打包到一个文件里。 同时我们将输出的filename用[name]变量来自动生成文件名，最后我们添加了一个CommonsChunkPlugin的插件，用于提取vendor。 12345678910Hash: ee1daf95c1986768927aVersion: webpack 2.3.2Time: 573ms Asset Size Chunks Chunk Names main.js 340 bytes 0 [emitted] mainvendor.js 274 kB 1 [emitted] [big] vendor [0] ./~/jquery/dist/jquery.js 267 kB &#123;1&#125; [built] [1] ./app/hello.js 53 bytes &#123;0&#125; [built] [2] ./app/index.js 114 bytes &#123;0&#125; [built] [3] multi jquery 28 bytes &#123;1&#125; [built] 最终发现我们成功将jQuery打包到了vendor.js中，实现了独立打包，但是问题又来了：每次打包后生成的文件名都是一样的，浏览器可能缓存上一次的结果而无法加载最新数据。 添加hash为了解决上述问题，我们需要为打包后的文件名添加hash值，这样每次修改后打包的文件hash值将改变，修改配置文件如下：12345678module.exports = &#123; ... output: &#123; filename: &apos;[name].[chunkHash:5].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, ...&#125; 上方我们在输出文件名中增加了[chunkHash:5]变量，表示打包后的文件中加入保留5位的hash值。我们再次运行打包命令：12345678910Hash: c7d1295f2f9a27c412d2Version: webpack 2.3.2Time: 603ms Asset Size Chunks Chunk Names main.2a7ad.js 337 bytes 0 [emitted] mainvendor.49eb4.js 274 kB 1 [emitted] [big] vendor [0] ./~/jquery/dist/jquery.js 267 kB &#123;1&#125; [built] [1] ./app/hello.js 50 bytes &#123;0&#125; [built] [2] ./app/index.js 114 bytes &#123;0&#125; [built] [3] multi jquery 28 bytes &#123;1&#125; [built] 上方我们发现打包后的文件成功加上了hash值，这样每次修改文件后hash值也会跟着变，就不怕浏览器缓存了，但是当我们尝试去修改一个js文件后再次打包，问题又来了：vendor.js的hash值也变了，我们并没有修改jQuery的源码。 修改vendor配置上述问题产生的原因是因为CommonsChunkPlugin插件是用于提取公共代码的，上方我们只是提取了vendor作为公共代码。为了继续解决上述问题，其实方法很简单，我们需要修改CommonsChunkPlugin的配置，如下：123456789module.exports = &#123; ... plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123; names: [&apos;vendor&apos;, &apos;manifest&apos;] &#125;), ] ...&#125; 如此我们修改一下hello.js中的代码，发现vendor的hash值并未改变，并且多了一个manifest.js的小文件。manifest.js为webpack的启动文件代码，它会直接影响到hash值，用mainfest单独抽出来了，这样vendor的hash就不会变了。 生成index.html通过以上对webpack配置文件的一系列修改，我们成功实现了webpack的独立打包与缓存处理，但是还差最后一步。 因为我们最终打包后生成的文件名中带有hash值，每次都是会变的，所以我们不能像目前这样在index.html中写死路径。 1234567...&lt;body&gt; &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./dist/vendor.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./dist/manifest.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;... 以上写法是不对的，因为缺少了可变的hash值，因此我们希望每次打包后index.html中的路径也会自动加上hash值，解决方法如下：1234567891011121314var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; ... plugins:[ ... new HtmlWebpackPlugin(&#123; title: &apos;demo&apos;, template: &apos;index.html&apos; // 模板路径 &#125;), ... ] ...&#125; 安装和配置完毕后，运行打包命令123456789101112Hash: 0c4b91e206579b31544dVersion: webpack 2.3.2Time: 856ms Asset Size Chunks Chunk Names vendor.e1868.js 268 kB 0 [emitted] [big] vendor main.44412.js 337 bytes 1 [emitted] mainmanifest.ed186.js 5.81 kB 2 [emitted] manifest index.html 292 bytes [emitted] [0] ./~/jquery/dist/jquery.js 267 kB &#123;0&#125; [built] [1] ./app/hello.js 50 bytes &#123;1&#125; [built] [2] ./app/index.js 114 bytes &#123;1&#125; [built] [3] multi jquery 28 bytes &#123;0&#125; [built] 我们发现在dist目录下生成了一个index.html文件，打开该文件后代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;manifest.ed186.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;vendor.e1868.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;main.44412.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"es6规范","date":"2018-03-19T09:25:22.000Z","path":"2018/03/19/blog2/","text":"es6 es7 es8 typescript 这些都是为了让一些语法逻辑更为简洁 常量12const a = xxxconst obj =&#123;&#125; 变量1let a = xxx 模版字符串传统的JavaScript语言，输出模板通常是这样写的。 12const welcome = 'You have logged in as ' + first + ' ' + last + '.'const db = 'http://' + host + ':' + port + '/' + database; ES6可以使用反引号和${}简写： 123const welcome = `You have logged in as $&#123;first&#125; $&#123;last&#125;`;const db = `http://$&#123;host&#125;:$&#123;port&#125;/$&#123;database&#125;`; 解构赋值简写方法123456789const observable = require('mobx/observable');const action = require('mobx/action');const runInAction = require('mobx/runInAction');const store = this.props.store;const form = this.props.form;const loading = this.props.loading;const errors = this.props.errors;const entity = this.props.entity; 简写:123import &#123; observable, action, runInAction &#125; from 'mobx';const &#123; store, form, loading, errors, entity &#125; = this.props; 扩展运算符简写扩展运算符有几种用例让JavaScript代码更加有效使用，可以用来代替某个数组函数。1234567// joining arraysconst odd = [1, 3, 5];const nums = [2 ,4 , 6].concat(odd);// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = arr.slice() 简写： 1234567const odd = [1, 3, 5 ];const nums = [2 ,4 , 6, ...odd];console.log(nums); // [ 2, 4, 6, 1, 3, 5 ]// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = [...arr]; 也可以使用扩展运算符解构： 1234const &#123; a, b, ...z &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(a) // 1console.log(b) // 2console.log(z) // &#123; c: 3, d: 4 &#125; 对象的扩展Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 数组方法Map filter forEach (es5常用) find方法 扩展符 想从数组中查找某个值，则需要循环。在ES6中，find()函数能实现同样效果。 12345678910111213const pets = [ &#123; type: 'Dog', name: 'Max'&#125;, &#123; type: 'Cat', name: 'Karl'&#125;, &#123; type: 'Dog', name: 'Tommy'&#125;,]function findDog(name) &#123; for(let i = 0; i&lt;pets.length; ++i) &#123; if(pets[i].type === 'Dog' &amp;&amp; pets[i].name === name) &#123; return pets[i]; &#125; &#125;&#125; 简写：12pet = pets.find(pet =&gt; pet.type ==='Dog' &amp;&amp; pet.name === 'Tommy');console.log(pet); // &#123; type: 'Dog', name: 'Tommy' &#125; 异步操作promise用法 链接 http://es6.ruanyifeng.com/#docs/promise async await 链接 http://es6.ruanyifeng.com/#docs/async","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]